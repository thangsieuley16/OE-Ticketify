<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AR Interface - Pro Control</title>

    <!-- HTTPS Check -->
    <script>
        if (location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
            document.write('<div style="background:red; color:white; width:100vw; height:100vh; display:flex; justify-content:center; align-items:center; text-align:center; font-size:24px; padding:20px; position:fixed; top:0; left:0; z-index:9999;">SECURITY ERROR: Camera requires HTTPS.<br>Please use Ngrok or Deploy to Vercel.</div>');
            throw new Error("HTTPS Required");
        }
    </script>

    <!-- Import Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">

    <!-- Tailwind CSS for UI layout -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Three.js for 3D Graphics -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <!-- MediaPipe Hands for Hand Tracking -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
            font-family: 'Share Tech Mono', monospace;
            color: #0ff;
        }

        /* Video element hidden */
        .input_video {
            display: none;
        }

        /* Main container layers */
        #canvas-container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        /* The webcam feed canvas */
        #output_canvas {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
            /* Mirror effect */
            z-index: 1;
            opacity: 0.8;
            object-fit: cover;
        }

        /* The 3D Three.js Overlay */
        #three_canvas {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
        }

        /* UI Overlay (HUD) */
        #ui-layer {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            z-index: 3;
            pointer-events: none;
        }

        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border: 1px solid #0ff;
            text-align: center;
        }
    </style>
</head>

<body>

    <!-- Loading Screen -->
    <div id="loading">
        <h2 class="text-2xl mb-2">INITIALIZING...</h2>
        <p>Đang tải camera...</p>
    </div>

    <!-- Hidden Video Source with iOS compatibility attributes -->
    <video class="input_video" playsinline webkit-playsinline muted autoplay></video>

    <div id="canvas-container">
        <!-- 2D Canvas -->
        <canvas id="output_canvas"></canvas>

        <!-- 3D Canvas -->
        <canvas id="three_canvas"></canvas>

        <!-- UI HUD Layer -->
        <div id="ui-layer" class="p-6 h-full relative">
            <!-- Central Target Reticle -->
            <div
                class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-64 h-64 border border-cyan-500/10 rounded-full flex items-center justify-center pointer-events-none opacity-50">
                <div class="w-56 h-56 border border-cyan-500/10 rounded-full border-dashed animate-spin-slow"></div>
            </div>

            <!-- Removed Bottom Status Bar as requested -->
        </div>
    </div>

    <script>
        // --- 1. STATE MANAGEMENT ---
        const state = {
            scale: 1.0,
            position: new THREE.Vector3(0, 0, 0),
            rotation: new THREE.Euler(0, 0, 0), // Target rotation
            autoRotateSpeed: 0.005,

            lastPinchDist: null,
            lastHandPos: null,
        };

        // --- 2. THREE.JS SETUP ---
        const threeCanvas = document.getElementById('three_canvas');
        const renderer = new THREE.WebGLRenderer({ canvas: threeCanvas, alpha: true, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);

        const scene = new THREE.Scene();

        // Mobile Optimization: Adjust FOV for Portrait Mode
        const isPortrait = window.innerHeight > window.innerWidth;
        const initialFov = isPortrait ? 100 : 50;

        const camera = new THREE.PerspectiveCamera(initialFov, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;

        // Create the Sphere
        const geometry = new THREE.IcosahedronGeometry(1, 2);
        const wireframeMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ffff,
            wireframe: true,
            transparent: true,
            opacity: 0.8
        });
        const sphere = new THREE.Mesh(geometry, wireframeMaterial);

        // Inner glow core
        const coreGeometry = new THREE.IcosahedronGeometry(0.8, 1);
        const coreMaterial = new THREE.MeshBasicMaterial({
            color: 0x0088ff,
            transparent: true,
            opacity: 0.2,
            wireframe: false
        });
        const core = new THREE.Mesh(coreGeometry, coreMaterial);
        sphere.add(core);

        // Floating particles
        const particlesGeom = new THREE.BufferGeometry();
        const particleCount = 100;
        const posArray = new Float32Array(particleCount * 3);
        for (let i = 0; i < particleCount * 3; i++) {
            posArray[i] = (Math.random() - 0.5) * 5;
        }
        particlesGeom.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        const particlesMat = new THREE.PointsMaterial({
            size: 0.02,
            color: 0x00ffff,
            transparent: true,
            opacity: 0.6
        });
        const particlesMesh = new THREE.Points(particlesGeom, particlesMat);
        sphere.add(particlesMesh);

        scene.add(sphere);

        // Resize handler
        window.addEventListener('resize', () => {
            const isPortraitNow = window.innerHeight > window.innerWidth;
            camera.fov = isPortraitNow ? 100 : 50;
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- 3. HELPER FUNCTIONS ---

        function isPinched(landmarks) {
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const distance = Math.sqrt(
                Math.pow(thumbTip.x - indexTip.x, 2) +
                Math.pow(thumbTip.y - indexTip.y, 2)
            );
            return distance < 0.05;
        }

        // Calculate Angle of hand (Wrist to Middle Finger MCP)
        function getHandAngle(landmarks) {
            const wrist = landmarks[0];
            const middleMCP = landmarks[9];

            const dx = middleMCP.x - wrist.x;
            const dy = middleMCP.y - wrist.y;

            return Math.atan2(dy, dx);
        }

        // --- 4. MEDIAPIPE LOGIC ---
        const videoElement = document.getElementsByClassName('input_video')[0];
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');

        function onResults(results) {
            document.getElementById('loading').style.display = 'none';

            // Draw Video
            canvasElement.width = window.innerWidth;
            canvasElement.height = window.innerHeight;
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

            // Draw Skeleton
            if (results.multiHandLandmarks) {
                for (const landmarks of results.multiHandLandmarks) {
                    const pinched = isPinched(landmarks);
                    const color = pinched ? '#00ffff' : 'rgba(255, 255, 255, 0.5)';
                    const thick = pinched ? 3 : 1;

                    drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS,
                        { color: color, lineWidth: thick });
                    drawLandmarks(canvasCtx, landmarks, { color: color, lineWidth: thick, radius: pinched ? 5 : 3 });
                }
            }
            canvasCtx.restore();

            // --- CORE LOGIC ---

            if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                state.lastPinchDist = null;
                return;
            }

            const landmarks = results.multiHandLandmarks;
            const handCount = landmarks.length;

            // --- 1. ZOOM LOGIC (2 Hands + Both Pinched) ---
            if (handCount === 2) {
                const hand1 = landmarks[0];
                const hand2 = landmarks[1];

                // Strict check: Both hands must be pinching to Zoom
                if (isPinched(hand1) && isPinched(hand2)) {
                    const p1 = hand1[9];
                    const p2 = hand2[9];
                    const dist = Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));

                    if (state.lastPinchDist !== null) {
                        const delta = dist - state.lastPinchDist;
                        state.scale += delta * 5;
                        if (state.scale < 0.2) state.scale = 0.2;
                        if (state.scale > 20.0) state.scale = 20.0; // MAX ZOOM 20x
                    }
                    state.lastPinchDist = dist;
                    return; // Exit to prevent conflict with other modes
                } else {
                    state.lastPinchDist = null;
                }
            }

            // --- 2. SINGLE HAND INTERACTIONS ---
            // We only take the first hand detected for control if not zooming
            const hand = landmarks[0];
            const pinched = isPinched(hand);
            const centerPoint = hand[9]; // Middle finger MCP

            // Coords: Mirror X for intuitive control
            const currentX = (0.5 - centerPoint.x) * 8;
            const currentY = (0.5 - centerPoint.y) * 6;

            if (pinched) {
                // --- MODE: GRAB & MOVE (Pinch) ---
                state.position.x += (currentX - state.position.x) * 0.15; // Snappier movement
                state.position.y += (currentY - state.position.y) * 0.15;
            } else {
                // --- MODE: ROTATE & HOVER (Open Palm) ---
                // "Placing sphere on palm"

                // Hover effect
                state.position.x += (currentX - state.position.x) * 0.08;
                state.position.y += ((currentY + 0.5) - state.position.y) * 0.08;

                // Calculate Hand Angle
                const angle = getHandAngle(hand); // Radians

                // Map Hand Angle to Sphere Rotation
                const neutralAngle = -Math.PI / 2;
                const relativeAngle = angle - neutralAngle;

                // Apply rotation
                state.rotation.z = -relativeAngle;
                state.rotation.y = relativeAngle * 1.5;
            }
        }

        // --- 5. ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            // 1. Apply Persistent Position & Scale
            sphere.position.x = state.position.x;
            sphere.position.y = state.position.y;

            sphere.scale.x += (state.scale - sphere.scale.x) * 0.1;
            sphere.scale.y += (state.scale - sphere.scale.y) * 0.1;
            sphere.scale.z += (state.scale - sphere.scale.z) * 0.1;

            // 2. Apply Rotation Logic
            sphere.rotation.z += (state.rotation.z - sphere.rotation.z) * 0.1;
            sphere.rotation.y += (state.rotation.y - sphere.rotation.y) * 0.1;

            // Subtle Idle rotation
            const slowFactor = Math.max(1, state.scale);
            sphere.rotation.x += 0.002 / slowFactor;

            // Pulse effect
            const time = Date.now() * 0.002;
            core.scale.setScalar(0.8 + Math.sin(time) * 0.1);

            renderer.render(scene, camera);
        }
        animate();

        // --- 6. INIT CAMERA & HANDS ---
        const hands = new Hands({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }
        });

        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.7
        });

        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({ image: videoElement });
            },
            width: 1280,
            height: 720
        });

        cameraUtils.start();
    </script>
</body>

</html>